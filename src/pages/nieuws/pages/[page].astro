---
// Import necessary components
import BaseHead from "../../../components/BaseHead.astro";
import BaseHeader from "../../../components/BaseHeader.astro";
import BaseScript from "../../../components/BaseScript.astro";
import BaseFooter from "../../../components/BaseFooter.astro";
import NewNavmenu from "../../../components/NewNavmenu.astro";
import BasePodcastBanner from "../../../components/BasePodcastBanner.astro";
import BaseNieuwsItem from "../../../components/BaseNieuwsItem.astro"; // Corrected component name from Niews to Nieuws
import BaseHeadExclude from "../../../components/BaseHeadExclude.astro";

import { getCollection } from "astro:content";
import { readFileSync } from "fs";
import { join } from "path";

export async function getStaticPaths({ paginate }) {
    // Load all news posts
    const allNieuwsPostsRaw = await getCollection("nieuws");
    const allNieuwsPosts = allNieuwsPostsRaw.filter(post => !post.data.draft);

    // Sort posts by date in descending order
    const sortedPosts = allNieuwsPosts.sort((a, b) => {
        return new Date(b.data.date).getTime() - new Date(a.data.date).getTime();
    });

    // Function to extract text from TinaCMS rich-text body
    function extractTextFromBody(body) {
        if (!body) return '';
        
        // If it's already a string, return it (strip markdown if needed)
        if (typeof body === 'string') {
            return body
                .replace(/---[\s\S]*?---/g, '') // Remove frontmatter
                .replace(/#{1,6}\s+/g, '') // Remove headers
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Convert links
                .replace(/\*\*([^*]+)\*\*/g, '$1') // Remove bold
                .replace(/\*([^*]+)\*/g, '$1') // Remove italic
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
        }
        
        // If it's an object with children array (TinaCMS rich-text structure)
        if (body && typeof body === 'object') {
            if (body.children && Array.isArray(body.children)) {
                const extractText = (node) => {
                    if (!node) return '';
                    
                    // Text node
                    if (node.type === 'text' && node.text) {
                        return node.text;
                    }
                    
                    // Node with children
                    if (node.children && Array.isArray(node.children)) {
                        return node.children.map(extractText).filter(Boolean).join(' ');
                    }
                    
                    return '';
                };
                
                const extracted = body.children
                    .map(extractText)
                    .filter(Boolean)
                    .join(' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                
                if (extracted) return extracted;
            }
        }
        
        return '';
    }

    // Function to extract text from MDX file for preview (fallback if bodyPreview is not available)
    function extractTextFromMDXFile(slug) {
        try {
            // Remove .mdx extension if present, then add it back to ensure correct path
            const cleanSlug = slug.replace(/\.mdx$/, "");
            const filePath = join(process.cwd(), "src/content/nieuws", `${cleanSlug}.mdx`);
            const content = readFileSync(filePath, "utf-8");
            if (!content || content.trim().length === 0) {
                return "";
            }
            
            // Remove frontmatter (more robust regex)
            const withoutFrontmatter = content.replace(/^---[\s\S]*?---\s*\n\n?/m, "");
            
            // Remove markdown syntax
            const text = withoutFrontmatter
                .replace(/#{1,6}\s+/g, "") // Remove headers
                .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1") // Convert links
                .replace(/\*\*([^*]+)\*\*/g, "$1") // Remove bold
                .replace(/\*([^*]+)\*/g, "$1") // Remove italic
                .replace(/!\[([^\]]*)\]\([^)]+\)/g, "") // Remove images
                .replace(/\s+/g, " ") // Normalize whitespace
                .trim();
            
            if (!text || text.length === 0) {
                return "";
            }
            
            return text.substring(0, 200) + (text.length > 200 ? "..." : "");
        } catch (e) {
            return "";
        }
    }

    // Helper function to ensure clean ID without .mdx extension
    function getCleanId(id) {
        return id ? id.replace(/\.mdx$/, '') : '';
    }

    // Map to format expected by pagination
    const mappedPosts = sortedPosts.map(post => {
        // Try bodyPreview first, then extract from body, then extract from MDX file directly
        let contentPreview = post.data.bodyPreview || extractTextFromBody(post.data.body) || "";
        
        // If still empty, try reading the MDX file directly
        if (!contentPreview && post.id) {
            contentPreview = extractTextFromMDXFile(post.id);
        }
        
        return {
            url: `/nieuws/${getCleanId(post.id)}`,
            frontmatter: post.data,
            rawContent: contentPreview,
        };
    });

    // Paginate the sorted array
    return paginate(mappedPosts, { pageSize: 8 });
}

const { page } = Astro.props;
const totalPages = page.lastPage; // Total number of pages
const currentPage = page.currentPage; // Current page number
const pageNumbersToShow = 5; // How many total pages to show in the navigation

function generatePageNumbers(currentPage, totalPages, pageNumbersToShow) {
    const halfWindow = Math.floor(pageNumbersToShow / 2);
    let start = Math.max(1, currentPage - halfWindow);
    let end = Math.min(totalPages, currentPage + halfWindow);

    // Adjust the start and end if they are out of bounds
    if (currentPage - halfWindow < 1) {
        end = Math.min(end + (halfWindow - currentPage + 1), totalPages);
    }
    if (currentPage + halfWindow > totalPages) {
        start = Math.max(1, start - (currentPage + halfWindow - totalPages));
    }

    return {start, end};
}

const {start, end} = generatePageNumbers(currentPage, totalPages, pageNumbersToShow);

exclude_from_search: true
---

<html lang="nl">
    <head>
        <BaseHeadExclude />
    </head>
    <body class="body">
        <div class="page-wrapper">
            <NewNavmenu />
            <BaseHeader />
            <div class="content">
                <div class="container">
                    <h1 class="nieuws-title">Film & TV nieuws</h1>
                    <div class="w-layout-grid nieuws-list">
                        <div class="categories-block">
                            <div class="title-large">CategorieÃ«n</div>
                            <div class="categories-wrapper list">
                                <a href="/nieuws/tags/film" class="categories-pill w-inline-block"><div class="title-small pink">Film</div></a>
                                <a href="/nieuws/tags/tv" class="categories-pill w-inline-block"><div class="title-small pink">TV</div></a>
                                <a href="/nieuws/tags/comics" class="categories-pill w-inline-block"><div class="title-small pink">Comics</div></a>
                                <a href="/nieuws/tags/trailer" class="categories-pill w-inline-block"><div class="title-small pink">Trailer</div></a>
                                <a href="/nieuws/tags/casting" class="categories-pill w-inline-block"><div class="title-small pink">Casting</div></a>
                            </div>
                        </div>
                        {page.data.map(post => (
                            <BaseNieuwsItem
                                key={post.url}
                                url={post.url}
                                title={post.frontmatter.title}
                                thumbnail={post.frontmatter.thumbnail}
                                date={post.frontmatter.date}
                                content={post.rawContent || ""}
                            />
                        ))}
                        <div class="pagination-wrapper">
                            <div class="pagination">
                                {page.url.prev ? <a href={page.url.prev} class="previous-button w-inline-block"><div class="title-medium">Vorige</div></a> : null}
                                {start > 1 ? <span>... </span> : null}
                                {Array.from({ length: end - start + 1 }, (_, i) => i + start).map(number =>
                                    number === currentPage ? (
                                        <strong class="page-indicator">{number}</strong>
                                    ) : (
                                        <a href={`/nieuws/pages/${number}`}>{number}</a>
                                    )
                                )}
                                {end < totalPages ? <span> ...</span> : null}
                                {page.url.next ? <a href={page.url.next} class="next-button w-inline-block"><div class="title-medium">Volgende</div></a> : null}
                            </div>
                        </div>
                    </div>
                </div>
            <BasePodcastBanner />
        </div>
        <BaseFooter />
    </body>
    <BaseScript />
</html>
